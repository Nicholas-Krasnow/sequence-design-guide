# sequence-design-guide
Protocol to redesign enzyme sequences with ProteinMPNN followed in Krasnow et. al. 2025

## Section I: generate residue constraints

### Distance analysis for active site constraints

This step will analyze the structure of your protein and measure the distance from each residue to the active site, generating list of constrained residues below a specified distance cutoff. Since it is likely that no structure of your protein has been solved in complex with substrate, the script is written to do the distance measurements on a homolog bound to substrate and map the constrained residues to your target protein. You can use a substrate-bound structure of the target protein if one is available or an AlphaFold3 model if you trust it.

Install required software: 
- distance_constraint_analysis.ipynb (Google Colab Notebook)

1.	Find a homolog of your target protein that is closely related in structure and has a structure solved with the substrate bound, or generate an AF3 structure. Download the pdb file of this substrate-bound structure.
2.	Create a folder in your Google Drive home directory titled ‘pdbs’. Upload the pdb file of the pdb of the homolog with substrate bound into this folder.
3.	Create a pairwise alignment between your protein sequence and the homolog protein sequence (this can be done in Geneious). The homolog should be the first sequence and the target protein should be the second. Export the alignment in .fasta format.
4.	Create a folder in your Google Drive home directory titled ‘fastas’. Upload the .fasta alignment from step 2.
5.	Upload the Colab notebook to your ‘Colab Notebooks’ folder to your Drive home directory.
6.	Run all the cells in the Colab Notebook one at a time, following instructions in the file as indicated in the text. Comments are provided to explain code and provide warnings for potential changes needed for different situations that weren't encounted in this paper. 

### Conservation analysis for evolutionary constraints

This step will conduct a sequence homology search to analyze the conservation of each residue. This information will be used after to generate lists of residues to constrain from design.

Required software: 

- BLAST+ (installation available at https://ftp.ncbi.nlm.nih.gov/blast/executables/LATEST/ and documentation available at https://www.ncbi.nlm.nih.gov/books/NBK279690/). 
- Python3 https://www.python.org/downloads/. Python pachages: biopython, pandas (install with pip with the terminal command e.g., pip install biopython)
- Jupyter notebook (https://jupyter.org/install)
- Conservation_and_constraints.ipynb 

BLAST+ Installation instructions provided below. For Python and Jupyter, follow instructions on the links provided.

1.	Download the executable file from the above link for your operating system (e.g., ncbi-blast-2.15.0+-x64-macosx.tar.gz. Double click to unzip and move the unzipped file to your documents   
2.	Add the program files to the Path so that your computer knows where to find them. Run the commands in the terminal:

`Echo PATH=$PATH:~/Documents/ncbi-blast-2.15.0+/bin>>.bashrc`

`Echo export PATH>>.bashrc`

`Source .bashrc`

Test the installation by entering 

`Blastp`

If this returns a blast-related error other than “command not found” then the installation was successful.

3.	Make a folder in your Documents where you’ll run blast analysis, name this folder blast_analysis. Make another folder in your Documents where you’ll store the database you’re searching, name this folder “dbs” (this folder should not be nested within blast_analysis)
4.	Put a .fasta file of your target protein sequence in the blast_analysis folder. The fasta file can be generated by exporting from Geneious, downloading from unprot, etc., and it will serve as the query for the homology search.
5.	Download the database in which you want to conduct the homology search. I used uniref50: https://www.uniprot.org/help/downloads. Unzip and move the downloaded fasta file to the dbs folder
6.	Convert the fasta file into a BLAST-searchable database with the terminal commands:
   
`cd ~/Documents/dbs`

`Makeblastdb -in uniref50.fasta -title uniref50 -dbtype prot -out uniref50 -parse_seqids`

8.	Run the blast search for your target protein against your chosen database with the terminal commands, replacing *.fasta with the name of your query sequence fasta file:

`cd ~/Documents/blast_analysis`

`blastp -query *.fasta -db ../dbs/uniref50 -out blast_out_table.tsv -evalue 1e-4 -outfmt 6`

A file named “blast_out_table.csv” will be generated which contains a list of homologs found. The -evalue flag value can be tuned to modulate the stringency of the search (smaller evalue = more stringent).
8.	Extract the sequences of the search hits: open the blast_out_table.csv file and copy the “ids” column values into a text file called hits.txt in the same folder (don’t include the column header). Run the terminal command:

`Blastdbcmd -db ../dbs/uniref50 -dbtype prot -entry_batch hits.txt -outfmt %f -out hits.fasta`

The file hits.fasta containing the sequence of each hit from the search should have been created. These search results will be used in the next step to quantify sequence conservation and generate the list of residues to constrain by conservation. 

9.	Copy the conservation_and_constraints.ipynb file to the directory that has the Blast anaylsis outputs
10.	Open Jupyter notebook with the terminal command: `jupyter notebook`. When jupyter opens, navigate to the folder with the .ipynb file and open it
11.	Run the cells one at a time, pasting in the names your target protein fasta and Blast output files where needed. Paste in the distance-constrained residue list when prompted. 
12.	Check the ‘_constraints.csv’ output generated. Confirm that the correct residues were selected using the pymol commands. The ‘MPNN fix string’ column will be used in the next step, which is to predict protein sequences using ProteinMPNN.

## Section II: sequence generation

### Generate redesigned sequences with ProteinMPNN

We will now set up the ProteinMPNN program code which will allow us to then deign sequences according to our constraints made in the previous steps. 

Software:

•	ProteinMPNN code: download the entire repository from github (https://github.com/dauparas/ProteinMPNN). Unzip and move to a safe place (e.g., documents)
•	Anaconda (https://docs.anaconda.com/free/anaconda/install/index.html). Confirm your installation by entering the command “conda” in the terminal; a list of conda commands should be printed
•	 Create a conda environment with the necessary packages to run ProteinMPNN by running the following terminal commands:

`conda create --name mlfold`

`source activate mlfold`

`conda install pytorch::pytorch torchvision torchaudio -c pytorch` refer to https://pytorch.org/ if the pytorch installation doesn’t work

`conda deactivate`

•	design_sequences_tutorial folder provided with this tutorial. Unzip and paste this folder into the ProteinMPNN folder with all the installed code

Steps:

1.	Introduce  your target structure pdb file: navigate to the design_sequences_tutorial folder in the ProteinMPNN folder. replace the target_structure folder (or target_structure_oligomer) with a folder with the same name as the pdb of your target structure. Paste the pdb into this folder. If you’re designing a multistate protein, you’ll need a single merged pdb with each conformation as a different chain. The two chains should be moved very far apart so that the model doesn’t misinterpret the two chains as forming interactions between each other.
2.	Make a copy of the sequence_design_monomer.sh script if designing a monomer, the sequence_design_homo-oligomer.sh file if doing a homo-oligomer, or sequence_design_multistate if designing a multistate protein. Rename it to describe your experiment/constraints.
3.	Open the .sh file and follow the instructions in the commented lines, indicating where to change the names of variables to reflect your target structure, your desired file names, your residue constraints, etc. 
4.	Run your .sh script on the terminal (e.g., sh sequence_design_monomer.sh). Outputs should be generated including a folder with a “seqs” subfolder containing your generated sequences

## Section III: post-processing and analysis of designed sequences

### Prepare sequences for alphafold prediction and run alphafold on the designed sequences

Software:

-PyMOL software https://pymol.org/ and the python package pymol

Scripts provided with the tutorial:

- deduplicate.ipynb
- rename_fastas_for_CO.ipynb
- unzip.sh
- extract_pdb.ipynb
- extract_pLDDT.ipynb
- calc_rmsd_pymol.py
  
Colabfold notebook for running large batches of alphafold predictions: 
- AF2multi_NAK.ipynb

Steps

Prepare files

1. Navigate back to the design_sequences_tutorial folder in the ProteinMPNN folder where you ran the sequence design script. Paste the deduplicate.ipynb and rename_fastas_for_CO.ipynb scripts here. 
2. Run deduplicate.ipynb, modifying the input fasta directories to your directories where your sequences were generated. 
3. Run rename_fastas_for_CO.ipynb to generate a fasta of the deduplicated sequences where each entry has a unique name. Make a copy of this fasta and manually add an entry for the WT sequence and any other controls you will test alongside your design.

Run alphafold

4. Make a copy of AF2multi_NAK.ipynb, the script for running predictions for a list of sequences in a fasta file. Change the runtime to A100 GPU. Change the fasta input directory and file to your uploaded fasta. Alphafold is now ready to be run with a few considerations specific to your protein:
   
AF2 will by default generate an MSA for each input protein and use that to find correlated residues. Designed sequences do not have evolutionary relatives so this may not make sense when doing protein design. Instead, we should changd the MSA mode to “custom” and specify the input MSA to be the MSA of the WT protein, which we could take from an AF2 prediction of the WT and upload that. Alternatively, we could run AF2 without any MSA at all, but would need to first confirm that AF2 can accurately predict the WT structure without an MSA since MSAs greatly enhance performance. MSA-free AF2, when possible, is probably better for ruling out MPNN sequences that don’t fold since the WT MSA may lead to bad MPNN sequences being predicted as false positives. Another idea is to remove the MSA but provide the WT structure as a template. 

The script is set to run predictions for monomers but the model type can be changed to  alphafold2_multimer for predicting complexes.

If you want to predict designs in complex with non-protein components such as small molecules, ions, nucleic acids, use AF3 or related models.

Analyze alphafold outputs

5. Download all the output zip files to a safe location, unzip with unzip.sh
6. Run extract_pdb.ipynb to make a folder of all the rank 1 prediciton pdbs
7. run extract_pLDDT.ipynb to analyze pLDDT scores. When plotting in the last step, change the bins and legend according to your parameter groups
8. Analyze rmsd with pymol: Open the pymol app. Open the calc_rmsd_pymol.py script, modifying inputs to your desired reference pdb (e.g., structure of the WT) and your pdbs_rank001 folder. During the plotting step, divide your data by parameter group as done before for pLDDTs.
9. Spot check some the predicted structures in pymol and confirm that they are consistent with the target structure.
10. If there are any outliers with poor agreement with the target structure they can be filtered out from the list to experimentally characterize. If scores are low and RMSDs high overall the design process or structure prediction should be revisited to figure out why before testing experimentally.

### Order synthetic genes of designs with cloning overhangs for experimental characterization

Protein sequences will be E. coli codon optimized and overhangs will be appended for golden gate cloning into a protein expression/purification backbone. 

Requirements:
LM627 golden gate acceptor plasmid map for expression/purification: https://www.addgene.org/191551/. This plasmid is compatible with golden gate cloning using the BsaI restriction enzyme. To improve cloning efficiency, the plasmid encodes a toxin that is replaced by the insert upon successful cloning so that cells transformed with unreacted acceptor plasmid do not grow into colonies while cells transformed with assembled plasmids will grow. To make stocks of cells or plasmid preps of acceptor LM627, the plasmid must therefore be transformed into a strain containing the antitoxin (i.e., NEB Stable cells)

1.	Go to the Genscript online codon optimization tool: https://www.genscript.com/tools/gensmart%2dcodon%2doptimization
2.	Upload the fasta file of all your deduplicated, renamed designs
3.	Specify the following flanking sequences for all entries: 5’ flanking ATACATATGTCGGTCTCAAGGA, 3’ flanking CATCATCACCATCACCATTGATTCCCGAGACCGGCAGCCATCA
4.	Set expression host to E. coli, set exclude sequences to exclude the restriction site BsaI [GGTCTC]
5.	Run codon optimization, save the output to as Excel file
6.	Confirm that the overhangs were designed correctly by checking that an example optimized sequence can be golden gate cloned with the LM627 acceptor plasmid using the Geneious cloning tool in the top taskbar
7.	Place an order for the output list of optimized sequences as synthetic genes (e.g., IDT eblocks)
